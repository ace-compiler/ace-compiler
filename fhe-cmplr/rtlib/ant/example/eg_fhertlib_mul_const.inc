//-*-c-*-
//=============================================================================
//
// Copyright (c) XXXX-XXXX
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//=============================================================================

// This file is auto generated by irb2c from FHE compiler,
// FHE compiler has plugined FHE operations into origin ONNX function
// and FHE operations has been lower to polynomial operation.

#include "rt_ant/rt_ant.h"

CKKS_PARAMS *Get_context_params() {
  static CKKS_PARAMS param = {
    LIB_ANT, 16, 0, 8, 33, 30, 0, 0
  };
  return &param;
}

DATA_SCHEME* Get_encode_scheme(int idx) {
  static DATA_SCHEME scheme_0 = {
    "input", {0, 0, 0, 0}, 1, {NORMAL, 0, 0, 0, 0}
  };
  static DATA_SCHEME* scheme[] = { &scheme_0 };
  return scheme[idx];
}

DATA_SCHEME* Get_decode_scheme(int idx) {
  static DATA_SCHEME scheme = {
    "output", {0, 0, 0, 0}, 1, {NORMAL, 0, 0, 0, 0}
  };
  return &scheme;
}

RT_DATA_INFO* Get_rt_data_info() {
  return NULL;
}

double add_const_val[] = {1.0};
size_t len = 1;

bool Main_graph() {
  CIPHERTEXT   input;
  CIPHERTEXT   output;
  uint32_t poly_loop_idx;
  uint32_t poly_loop_p_idx;
  MODULUS* modulus = Q_modulus();
  MODULUS* p_modulus = P_modulus();
  uint32_t degree  = Degree();
  int64_t* poly_dst;
  int64_t* poly_src0;
  int64_t* poly_src1;
  input     = Get_input_data("input", 0);
  memset(&output, 0, sizeof(output));

  // encode plaintext from const_val
  PLAINTEXT onnx_add_1;
  memset(&onnx_add_1, 0, sizeof(onnx_add_1));
  Encode_plain_from_double(&onnx_add_1, add_const_val, len, 1, 0);

  // alloc output ciphertext
  Init_ciph_up_scale_plain(&output, &input, &onnx_add_1);

  // output = input + onnx_add_1
  for (poly_loop_idx = 0; poly_loop_idx < Level(&output);
       poly_loop_idx += 0x1) {
    poly_dst  = Coeffs(&(output._c0_poly), poly_loop_idx, degree);
    poly_src0 = Coeffs(&(input._c0_poly), poly_loop_idx, degree);
    poly_src1 = Coeffs(&(onnx_add_1._poly), poly_loop_idx, degree);
    Hw_modmul(poly_dst, poly_src0, poly_src1, modulus, degree);
    poly_dst  = Coeffs(&(output._c1_poly), poly_loop_idx, degree);
    poly_src0 = Coeffs(&(input._c1_poly), poly_loop_idx, degree);
    Hw_modmul(poly_dst, poly_src0, poly_src1, modulus, degree);
    modulus++;
  }
  Init_ciph_down_scale(&output, &output);
  Rescale(&(output._c0_poly), &(output._c0_poly));
  Rescale(&(output._c1_poly), &(output._c1_poly));
  Set_output_data("output", 0, &output);
  return true;
}

int Get_output_count() {
  return 1;
}

int Get_input_count() {
  return 1;
}
