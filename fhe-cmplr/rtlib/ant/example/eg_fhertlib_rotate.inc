//-*-c-*-
//=============================================================================
//
// Copyright (c) XXXX-XXXX
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//=============================================================================

// This file is auto generated by irb2c from FHE compiler,
// FHE compiler has plugined FHE operations into origin ONNX function
// and FHE operations has been lower to polynomial operation.

#include "rt_ant/rt_ant.h"

CKKS_PARAMS* Get_context_params() {
  static CKKS_PARAMS param = {
      LIB_ANT, 16, 0, 8, 33, 30, 0, 0, 5, {6, 14, 2, 5, 16}
  };
  return &param;
}

DATA_SCHEME* Get_encode_scheme(int idx) {
  static DATA_SCHEME scheme_0 = {
    "input", {0, 0, 0, 0}, 1, {NORMAL, 0, 0, 0, 0}
  };
  static DATA_SCHEME* scheme[] = { &scheme_0 };
  return scheme[idx];
}

DATA_SCHEME* Get_decode_scheme(int idx) {
  static DATA_SCHEME scheme = {
    "output", {0, 0, 0, 0}, 1, {NORMAL, 0, 0, 0, 0}
  };
  return &scheme;
}

RT_DATA_INFO* Get_rt_data_info() {
  return NULL;
}

int32_t Rot_idx = 2;

bool Main_graph() {
  CIPHERTEXT   input;
  CIPHERTEXT   output;
  uint32_t part_idx;
  uint32_t l_idx;
  uint32_t p_idx;
  MODULUS *modulus;
  uint32_t degree = Degree();
  int64_t *poly_dst;
  int64_t *poly_src0;
  int64_t *poly_src1;
  int64_t *rot_precomp;
  input = Get_input_data("input", 0);

  // alloc output ciphertext
  memset(&output, 0, sizeof(output));
  Init_ciph_same_scale(&output, &input, NULL);

  POLY c0 = &(input._c0_poly);
  POLY c1 = &(input._c1_poly);

  POLY decomp_poly, raised, sw_c0, sw_c1, temp_c0, temp_c1, temp_c2;
  decomp_poly = Alloc_poly(degree, Level(&input), FALSE);
  raised      = Alloc_poly(degree, Level(&input), TRUE);
  sw_c0       = Alloc_poly(degree, Level(&input), TRUE);
  sw_c1       = Alloc_poly(degree, Level(&input), TRUE);
  temp_c0     = Alloc_poly(degree, 1, FALSE);
  temp_c1     = Alloc_poly(degree, Level(&input), FALSE);
  temp_c2     = Alloc_poly(degree, Level(&input), FALSE);

  rot_precomp    = Auto_order(Rot_idx);
  SW_KEY swk = Swk(true, Rot_idx);

  for (part_idx = 0; part_idx < Num_decomp(c1); part_idx++) {
    POLY    key0, key1;
    key0 = Pk0_at(swk, part_idx);
    key1 = Pk1_at(swk, part_idx);

    // precomputed
    Decomp(decomp_poly, c1, part_idx);
    Mod_up(raised, decomp_poly, part_idx);

    // fast switch key
    modulus = Q_modulus();
    for (l_idx = 0; l_idx < Poly_level(raised); l_idx++) {
      Hw_modmul(Coeffs(temp_c0, 0, degree),
                   Coeffs(key0, l_idx, degree),
                   Coeffs(raised, l_idx, degree), modulus, degree);
      Hw_modadd(Coeffs(sw_c0, l_idx, degree),
                   Coeffs(sw_c0, l_idx, degree),
                   Coeffs(temp_c0, 0, degree), modulus, degree);
      Hw_modmul(Coeffs(temp_c0, 0, degree),
                   Coeffs(key1, l_idx, degree),
                   Coeffs(raised, l_idx, degree), modulus, degree);
      Hw_modadd(Coeffs(sw_c1, l_idx, degree),
                   Coeffs(sw_c1, l_idx, degree),
                   Coeffs(temp_c0, 0, degree), modulus, degree);
      modulus++;
    }
    modulus         = P_modulus();
    uint32_t p_ofst = Num_alloc(raised) - Num_p(raised);
    for (l_idx = 0; l_idx < Num_p(raised); l_idx++) {
      p_idx = l_idx + p_ofst;
      Hw_modmul(Coeffs(temp_c0, 0, degree),
                   Coeffs(key0, p_idx, degree),
                   Coeffs(raised, p_idx, degree), modulus, degree);
      Hw_modadd(Coeffs(sw_c0, p_idx, degree),
                   Coeffs(sw_c0, p_idx, degree),
                   Coeffs(temp_c0, 0, degree), modulus, degree);
      Hw_modmul(Coeffs(temp_c0, 0, degree),
                   Coeffs(key1, p_idx, degree),
                   Coeffs(raised, p_idx, degree), modulus, degree);
      Hw_modadd(Coeffs(sw_c1, p_idx, degree),
                   Coeffs(sw_c1, p_idx, degree),
                   Coeffs(temp_c0, 0, degree), modulus, degree);
      modulus++;
    }
  }
  Mod_down(temp_c1, sw_c0);
  Mod_down(temp_c2, sw_c1);

  Free_poly(decomp_poly);
  Free_poly(raised);
  Free_poly(sw_c0);
  Free_poly(sw_c1);

  // add poly
  modulus = Q_modulus();
  for (l_idx = 0; l_idx < Poly_level(temp_c1); l_idx++) {
    Hw_modadd(Coeffs(temp_c1, l_idx, degree),
                 Coeffs(temp_c1, l_idx, degree),
                 Coeffs(c0, l_idx, degree), modulus, degree);
    modulus++;
  }

  // rotate poly
  modulus = Q_modulus();
  for (l_idx = 0; l_idx < Poly_level(temp_c1); l_idx++) {
    Hw_rotate(Coeffs(&(output._c0_poly), l_idx, degree),
              Coeffs(temp_c1, l_idx, degree), rot_precomp, modulus, degree);
    Hw_rotate(Coeffs(&(output._c1_poly), l_idx, degree),
              Coeffs(temp_c2, l_idx, degree), rot_precomp, modulus, degree);
    modulus++;
  }
  Free_poly(temp_c0);
  Free_poly(temp_c1);
  Free_poly(temp_c2);

  Set_output_data("output", 0, &output);
  return true;
}

int Get_output_count() {
  return 1;
}

int Get_input_count() {
  return 1;
}