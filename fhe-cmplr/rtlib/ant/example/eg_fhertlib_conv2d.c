//-*-c-*-
//=============================================================================
//
// Copyright (c) XXXX-XXXX
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//=============================================================================

// This file should be auto generated by onnx2c.py,
// it's used as driver for testing ONNX.

#include <math.h>

#include "common/rtlib.h"

double Expected_data[] = {
    0.109734416, 0.23362316,  0.046415076, -0.15926808, -0.67267114,
    -0.55595946, 0.08955735,  -0.48043144, 0.10056494,  -0.3531828,
    -0.15128364, -0.99107844, 0.4195959,   -0.73524076, -0.0122145265,
    0.43661183,  -0.38402185, 0.27585578,  -0.63143295, -0.99207675,
    -0.7395694,  -0.75199515, -0.6055116,  -0.3447394,  -0.15953597};
int Expected_len = 25;

/**
 * @brief generate input data for testing ONNX
 *
 *
 * @param n
 * @param c
 * @param h
 * @param w
 * @param data, data pointer
 * @return TENSOR input data
 */
TENSOR* Generate_input_data(size_t n, size_t c, size_t h, size_t w,
                            double* data) {
  return Alloc_tensor(n, c, h, w, data);
}

/**
 * @brief validate output vector with expect vector
 *
 *
 * @param result double *
 * @param expect double *
 * @param len int
 * @return return true if value match
 */
bool Validate_output_data(double* result, double* expect, int len) {
  double error = 1e-3;
  for (int i = 0; i < len; i++) {
    if (fabs(result[i] - expect[i]) > error) {
      printf("index: %d, value: %f != %f\n", i, result[i], expect[i]);
      return false;
    }
  }
  return true;
}

int main(int argc, char* argv[]) {
  Prepare_context();

  double input1[] = {
      0.3427312672138214,   -0.2430942803621292,   -0.7524965405464172,
      0.28900882601737976,  -0.21131457388401031,  1.1161503791809082,
      -1.9553654193878174,  0.309954971075058,     -0.8903464078903198,
      -0.29043203592300415, -1.0801938772201538,   -1.4440861940383911,
      -0.466877281665802,   0.18298505246639252,   0.2872512638568878,
      1.0310099124908447,   -0.027195485308766365, -0.0796319916844368,
      0.3324432373046875,   -0.4316408634185791,   0.7105830311775208,
      0.5238034129142761,   1.1334749460220337,    -1.1573430299758911,
      -0.28867360949516296, 0.688653290271759,     -0.428383469581604,
      -0.9977264404296875,  -0.4736612141132355,   0.3369980454444885,
      -0.2344815731048584,  1.2287367582321167,    1.1167821884155273,
      0.7653115391731262,   -0.3811981976032257,   -1.5193971395492554,
      -0.4690782427787781,  0.08200068771839142,   -1.0223075151443481,
      1.1111479997634888,   -0.9628414511680603,   -0.543373167514801,
      -1.3220964670181274,  0.017166657373309135,  0.9434011578559875,
      0.8278883695602417,   1.759674310684204,     0.35604286193847656,
      0.14254696667194366,  0.19280679523944855,   -0.5591102838516235,
      0.2576371133327484,   0.39390188455581665,   -0.3445994257926941,
      0.8220220804214478,   1.6074227094650269,    -1.4399993419647217,
      -0.2610258460044861,  -1.1937615871429443,   -1.616551399230957,
      0.1459829956293106,   1.4738240242004395,    0.10827099531888962,
      0.13907349109649658,  -1.2322616577148438,   -1.2188061475753784,
      0.4072338342666626,   -1.4149335622787476,   -0.5189498066902161,
      0.8217626214027405,   1.1679283380508423,    -1.10842764377594,
      -0.8336210250854492,  -1.077689290046692,    -0.6114354133605957};
  TENSOR* input_data1 = Generate_input_data(1, 3, 5, 5, input1);
  printf("input");
  Print_tensor(stdout, input_data1);
  Prepare_input(input_data1, "input");
  Free_tensor(input_data1);

  Run_main_graph();

  double* result = Handle_output("output");

  Finalize_context();

  bool res = Validate_output_data(result, Expected_data, Expected_len);
  free(result);
  if (res) {
    printf("SUCESS!\n");
  } else {
    printf("FAILED!\n");
    return 1;
  }

  return 0;
}
#include "eg_fhertlib_conv2d.inc"