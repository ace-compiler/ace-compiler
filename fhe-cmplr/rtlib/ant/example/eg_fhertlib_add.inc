//-*-c-*-
//=============================================================================
//
// Copyright (c) XXXX-XXXX
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//=============================================================================

// This file is auto generated by irb2c from FHE compiler,
// FHE compiler has plugined FHE operations into origin ONNX function
// and tensor operations has been lower to polynomial operation.

#include "rt_ant/rt_ant.h"

CKKS_PARAMS *Get_context_params() {
  static CKKS_PARAMS param = {._provider         = LIB_ANT,
                              ._poly_degree      = 1024,
                              ._sec_level        = 0,
                              ._mul_depth        = 3,
                              ._first_mod_size   = 33,
                              ._scaling_mod_size = 30,
                              ._num_q_parts      = 0};
  return &param;
}

DATA_SCHEME* Get_encode_scheme(int idx) {
  static DATA_SCHEME scheme_0 = {
    "input", {0, 0, 0, 0}, 1, {NORMAL, 0, 0, 0, 0}
  };
  static DATA_SCHEME scheme_1 = {
    "onnx::Add_1", {0, 0, 0, 0}, 1, {NORMAL, 0, 0, 0, 0}
  };
  static DATA_SCHEME* scheme[] = { &scheme_0, &scheme_1 };
  return scheme[idx];
}

DATA_SCHEME* Get_decode_scheme(int idx) {
  static DATA_SCHEME scheme = {
    "output", {0, 0, 0, 0}, 1, {NORMAL, 0, 0, 0, 0}
  };
  return &scheme;
}

RT_DATA_INFO* Get_rt_data_info() {
  return NULL;
}

int Get_output_count() {
  return 1;
}

int Get_input_count() {
  return 2;
}

bool Main_graph() {
  CIPHERTEXT   input;
  CIPHERTEXT   onnx_add_1;
  CIPHERTEXT   output;
  uint32_t poly_loop_idx;
  MODULUS* modulus = Q_modulus();
  uint32_t degree  = Degree();
  int64_t* poly_dst;
  int64_t* poly_src0;
  int64_t* poly_src1;
  input      = Get_input_data("input", 0);
  onnx_add_1 = Get_input_data("onnx::Add_1", 0);
  memset(&output, 0, sizeof(output));
  Init_ciph_same_scale(&output, &input, &onnx_add_1);

  for (poly_loop_idx = 0; poly_loop_idx < Level(&output);
       poly_loop_idx += 0x1) {
    poly_dst  = Coeffs(&(output._c0_poly), poly_loop_idx, degree);
    poly_src0 = Coeffs(&(input._c0_poly), poly_loop_idx, degree);
    poly_src1 = Coeffs(&(onnx_add_1._c0_poly), poly_loop_idx, degree);
    Hw_modadd(poly_dst, poly_src0, poly_src1, modulus, degree);
    poly_dst  = Coeffs(&(output._c1_poly), poly_loop_idx, degree);
    poly_src0 = Coeffs(&(input._c1_poly), poly_loop_idx, degree);
    poly_src1 = Coeffs(&(onnx_add_1._c1_poly), poly_loop_idx, degree);
    Hw_modadd(poly_dst, poly_src0, poly_src1, modulus, degree);
    modulus++;
  }
  Set_output_data("output", 0, &output);
  return true;
}
