@[TOC](MESSAGE.MD)

# API for messages in AVHC	
 - CMPLR_ERR_MSG (...)
 - CMPLR_WARN_MSG (...)
 - TRACE_MSG (...)
 - CMPLR_USR_MSG (Severity, ...)
## Two kinds of messages 1. User input related and 2. compiler internal related。

User input related messages are due to user input source code. Compiler internal messages are due to internal compiler process (such as ranslation, analysis, optimization and I/O)：
 
 ## Category of messages includes:
 - **Note** - that which is purely informational
 - **Warning** - Warning 
 - **Error** - non-fatal, compilation process will continue	
 - **Fatal** - fatal error, compilation process will terminate immediately
Messages of category **Error** and **Fatal** will be output to *cout* and *cerr*
	
 ## Format of user input message
	1. Message categpry
 	2. The specific message itself
 	3. line/column position of user input source file
	e.g. -  Error: var userVarX is uninitialized at line <123, 45>
## Format of compiler internal message
	1. offending compiler source file name and line
	2. Message category
	3. The specific message itself
	e.g. - cmplr_src.cxx:567: Error: This is cmplr testing payload bar 0x123456,  float 0.1234, char b## Compiler internal message format
##  Public APIs for compiler internal message

 - **CMPLR_ERR_MSG (...)**
 - 		where "..." is the typical free format of a printf statement in C
 - 	e.g.  *CMPLR_ERR_MSG("This is cmplr testing ERROR payload %s 0x%llx, in float, %f, char %c", "bar", hex_val, f, 'b');*
 - actual output: 
		 *good_basic.cxx:110: Error: This is cmplr testing ERROR payload bar 0x3735928559, in float, 0.1234, char b*
 -  **CMPLR_WARN_MSG(...)**
 -	e.g.  *CMPLR_WARN_MSG("This is cmplr testing WARNING payload %s 0x%llx, in float, %f, char %c", "bar", hex_val, f, 'b');* 
 **-	actual output:**
 *-	good_basic.cxx:112: Warning: This is cmplr testing payload bar 0x3735928559, in float, 0.1234, char b* 
 - **TRACE_MSG(...)**
 - 	e.g。	  *TRACE_MSG("Second Tracing\n");*
 - **acutal output:**
 *good_basic.cxx:132: Note: Second Tracing*
 
 	Note that right now, until "Trace_File_Name() and Trace_File() has been properly implemented, we simply output to cout.
 	
 -  **AIR_ASSERT(Cond_stmt, ...)**
 - 	e.g.   *AIR_ASSERT(( (localj == 0)), "%s should be %d", "assert part", 999);*
 -  **actual output** when (localj == 0) is evaluated to be **true**:
 	*- good_basic.cxx:114: Assertion Failure: assert part should be 999*
 	
 ## Public APIs for user message during compile/analysis/optimize phases
 	**CMPLR_USR_MSG(Severity, ...)** 
 	e.g 1:
 		CMPLR_USR_MSG(U_CODE::Uninit, "variableY", 123, 55);
	actual output:
		Error: var variableX is uninitialized at line <123, 55>
		
	e.g. 2:  
		int line124 = 124;
		...
		CMPLR_USR_MSG(U_CODE::Uninit, "variableY", line124, 55);
	actual output:
		Error: var variableY is uninitialized at line <124, 55>
		
**Important notes:** 

1. Severity is an enum class declared as follows: 
	*enum class SEVL {
 	 IGNORE    = 0,
 	 NOTE      = 1,
 	 WARN      = 2,
 	 ERR       = 3,
 	 ERRSAADV1 = 4,    // static analysis advisary  
 	 ERRSAADV2 = 5,
 	 ERRSAADV3 = 6,
 	 ERRSAADV4 = 7,
 	 ERRPHASE  = 9,    // error but finish phase before exit
 	 ERRFATAL  = 10,
  };*
  Each element in the enum has a corresponding literal for display. 
  
  2. The free format is actually semi-free. We **only support the following % format:  INT32, STRING, INT64** at the moment
  3. It is **important *not* to support all possible formatting forms** since the implementation is variadic template based. Full implementation will cause excessive code bloat for the compiler. (also, %x and %llx has yet to be implemented). We also limit the ***number of %?*** to **maximum of 5** to output for implementation simplicity.
## How to *add* user message:
*All user messages will go through **an external tool*** to unify the message format, check for consistency and other good stuff. The user message class User_msg[] is generated by a tool. 

Example of the table is below:
*const static MSG_DESC User_msg[] = {
  { U_CODE::Src_File_Open_Err, SEVL::ERRFATAL,
	    "Input file open error",
            ERRT_DESC::STRING, ERRT_DESC::NONE, ERRT_DESC::NONE, ERRT_DESC::NONE, ERRT_DESC::NONE },
  { U_CODE::Uninit, SEVL::ERR,
              "var %s is uninitialized at line <%d, %d>",
              ERRT_DESC::STRING, ERRT_DESC::INT32, ERRT_DESC::INT32, ERRT_DESC::NONE, ERRT_DESC::NONE},
  { U_CODE::GOT_Size_Conflict, SEVL::WARN, 
    	      "Both large and small GOT requested, using default %d",
    	      ERRT_DESC::INT32, ERRT_DESC::NONE, ERRT_DESC::NONE, ERRT_DESC::NONE, ERRT_DESC::NONE },
  { U_CODE::Elf_Ofst64_Error,  SEVL::ERR, 
	      "ELF offset %x error %s",
              ERRT_DESC::INT64, ERRT_DESC::STRING, ERRT_DESC::NONE, ERRT_DESC::NONE, ERRT_DESC::NONE },
  { U_CODE::Srcfile_Not_Found, SEVL::ERRFATAL, 
    	      "Source file %s not found",
    	      ERRT_DESC::STRING, ERRT_DESC::NONE, ERRT_DESC::NONE, ERRT_DESC::NONE, ERRT_DESC::NONE },
};*